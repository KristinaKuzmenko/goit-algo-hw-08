import heapq
import random

"""
Є декілька мережевих кабелів різної довжини, їх потрібно об'єднати по два за раз в один кабель, використовуючи з'єднувачі,
 у порядку, який призведе до найменших витрат. Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин, 
 а загальні витрати дорівнюють сумі з'єднання всіх кабелів.
Завдання полягає в тому, щоб знайти порядок об'єднання, який мінімізує загальні витрати.
"""


def min_sum(l):
    """
    Розраховуємо мінімальні витрати на об'єднання кабелів.

    Args:
    l (list): Список довжин кабелів

    Returns:
    int: Мінімальні витрати на об'єднання кабелів
    """

    heapq.heapify(l)
    cumulative_sum = 0
    while len(l) > 1:
        first = heapq.heappop(l)
        second = heapq.heappop(l)
        sum = first + second
        print (f"| {first:<3} {"та"} {second:<25} | {sum:<10} |")
        cumulative_sum += sum
        heapq.heappush(l, sum)
    return cumulative_sum


# Тестування
sample_list = [random.randint(1, 20) for _ in range(20)]
print("Довжини кабелів: ", sample_list)
print("Порядок об'єднання кабелів: ")
print(f"| {'З\'єднання кабелів з довжинами':<32} | {'Витрати':<10} |")
print(f"| {'-'*32} | {'-'*10} |")
print("Мінімальні загальні витрати на об'єднання кабелів: ", min_sum(sample_list))